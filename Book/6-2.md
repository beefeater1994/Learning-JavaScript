# 词法作用域
词法化的过程会对源代码中的字符进行检查，如果是有状态的解析过程，还会赋予单词语义。

无论函数在哪里被调用，无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。

## 欺骗词法

### eval

```js
    function foo(str, a) {
        eval(str); //欺骗！
        console.log(a,b);
    }

    var b = 2;

    foo("var b = 3;", 1); //1,3
```

`eval(... )` 可以在运行期修改书写期的词法作用域。还有 `setTimeout(..)` 和 `setInterval(...)` 的第一个参数可以是字符串，字符串的内容可被解释为一段动态生成的函数代码（不推荐）。`new Function(..)``函数行为也类似。最后一个参数可以接受代码字符串，并将其转为动态生成的函数。

### with

`with` 可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域。

```js
    function foo(obj) {
        with(obj) {
            a = 2;
        }
    }

    var o1 = {
        a:3
    };

    var o2 = {
        b:3
    };

    foo(o1);
    console.log(o1.a); //2
    foo(o2);
    console.log(o2.a); // undefined
    console.log(a); //2
```


## 小结

词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。编译的词法分析阶段
基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找。

JavaScript 中有两个机制可以“欺骗”词法作用域：`eval(...)` 和 `with(...)`。 前者可以对一段包含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域（在运行时）。后者本质上是通过将一个对象的引用当做作用域来处理，将对象的属性当做作用域中的标识符来处理，从而创建了一个新的词法作用域（同样是运行时）。

这两个机制的副作用是引擎无法再编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的。使用其中任何一个机制都将导致代码运行变慢，不要使用它们。
